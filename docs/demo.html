
<!-- Add some basic style -->
<style>
/* A simple color model */
:root{
	--color1:white;/* Background */
	--color2:black;/* Foreground */
	--color3:grey;/* Highlights */
}

/* Dark mode color model */
@media (prefers-color-scheme: dark){
	:root{
		--color1:rgb(4,3,3);
		--color2:rgb(161,51,51);
		--color3:rgb(179,84,30);
	}
}

/* Main document */
body{
	background-color:var(--color1);
}

/* Main document elements without headers and fenced code */
body>*:not(pre):not(code):not(h1):not(h2):not(h3):not(h4):not(h5):not(h6),body>*:not(pre) *{
	font-family:Calibri,Verdana;
	color:var(--color2);
}

/* Headers */
h1,h2,h3,h4,h5,h6{
	font-family:Calibri,Verdana;
	color:var(--color3);
}

/* Inline code */
code:not([class]){
	font-family:monospace;
	background-color:var(--color3);
	color:var(--color1);
	padding-left:8px;
	padding-right:8px;
	border-radius:4px;
}

/* Fenced code */
pre>code{
	max-height:450px;
	overflow:auto;
	border:1px solid var(--color3);
	border-radius:4px;
}
</style>

<!-- The generated HTML -->
<h1>PHP MarkDown Server</h1>

<p><a href="https://www.markdownguide.org/">MarkDown</a> is used in many places for writing documentations and other stuff and widely supported in many environments. However, creating websites using MarkDown isn&#39;t a really new idea (-&gt; GitHub pages), but how could you serve a MarkDown website DIY?</p>

<p>I found some solutions for hosting MarkDown websites, but none of them really satisfied me. Especially when it comes to the performance, because none of them included a cache, so the MarkDown had to be processed for each call. Or they don&#39;t allow customization. Or they include their own script language to be mixed within MarkDown, which is just a bit too much... Or they simply didn&#39;t support the MarkDown features that I require. Or they&#39;re just too complicated to setup.</p>

<p>My approach is to use Apache with <code>mod_rewrite</code> as webserver, and simple PHP as gateway to output (cached) HTML. You can use any CLI tool to convert MarkDown to HTML - I tried the <code>markdown</code> and <code>redcarpet</code> (<a href="https://github.com/vmg/redcarpet">https://github.com/vmg/redcarpet</a>) commands. These features are included currently:</p>

<ul>
<li>Custom header/footer</li>
<li>Client/Server cache</li>
<li>PHP hook</li>
</ul>

<h2>Pre-requirements</h2>

<ol>
<li>Apache webserver with <code>mod_rewrite</code> enabled and <code>.htaccess</code> configured</li>
<li>PHP</li>
<li>Any CLI MarkDown to HTML converter</li>
</ol>

<h3>MarkDown converter Debian Linux setup</h3>

<h4>Using <code>markdown</code> as converter</h4>

<pre><code>apt install markdown
</code></pre>

<p>(Example command line is in <code>mdserver.php</code>)</p>

<h4>Using <code>redcarpet</code> as converter</h4>

<pre><code>apt install ruby-redcarpet
</code></pre>

<p>(Example command line is in <code>mdserver.php</code>)</p>

<h2>Webspace setup</h2>

<p>In the MarkDown webroot you&#39;ll need to place a <code>.htaccess</code> and the <code>mdserver.php</code> file along with the <code>mdserver.conf.php</code> file. The PHP script will use a writable folder to cache the generated HTML (which may be the MarkDown webroot folder).</p>

<p>The <code>.htaccess</code> file contents:</p>

<pre><code># Use index.md as directory index
DirectoryIndex index.md

# Prepare rewrite
RewriteEngine on
RewriteBase /mdwebroot/

# Deny direct access to internal files that shouldn&#39;t be called from a browser
RewriteRule \/md(server|header|footer)(\.hook|\.conf)?\.(html|php)$ - [NC,F]

# Process MarkDown files using the mdserver.php
RewriteCond %{REQUEST_FILENAME} \.md$ [NC]
RewriteCond %{LA-U:REQUEST_FILENAME} -f
RewriteCond %{LA-U:REQUEST_FILENAME} !-d
RewriteRule ^(.*)$ /path/to/mdwebroot/mdserver.php/$1/ [NC,L]
</code></pre>

<p>Please replace <code>/mdwebroot/</code> with the MarkDown webroot path of your webspace, and <code>/path/to/mdwebroot/mdserver.php</code> with the full local path to the <code>mdserver.php</code> file.</p>

<p>In the <code>mdserver.conf.php</code> file please edit the configuration first:</p>

<ul>
<li><code>HTML_CACHE_DIR</code>: This should point to a writable folder that will be used as cache folder for the generated HTML files (skip a trailing slash)</li>
<li><code>CACHE_ENABLED</code>: If the cache is enabled in general</li>
<li><code>MKDIR_MODE</code>: The filesystem access mode for new folders within the cache folder</li>
<li><code>MAX_CACHE_TIME</code>: Maximum client cache time in seconds (this value will be sent to a client browser)</li>
<li><code>MD_TO_HTML_CMD</code>: CLI command to use to convert a MarkDown file to HTML (variables <code>{mdfile}</code> points to the full local MarkDown file path, <code>{htmlfile}</code> to the full local HTML file path, both values are shell argument escaped)</li>
</ul>

<p>Now you&#39;re done already:</p>

<pre><code>https://uri.to/mdwebroot/index.md
</code></pre>

<p>If you&#39;ve used the demo files, you should be able to see the generated HTML website in your browser, when you point to this URI (of course replace the dummys with your configured webspace URI).</p>

<p>To see how the served <code>index.md</code> from the <code>demo</code> folder should look: <a href="https://nd1012.github.io/MarkDown-Server/demo.html">https://nd1012.github.io/MarkDown-Server/demo.html</a>.</p>

<h2>How it works</h2>

<p>The <code>.htaccess</code> configuration will make an internal redirect to the <code>mdserver.php</code> file, which then outputs the generated HTML. For this, the PHP script will have a look at the cache folder structure, if the HTML file exists. The HTML filename is the MarkDown filename with the <code>.html</code> postfix. Every time you update the MarkDown source file, the PHP script will re-create the HTML file to the cache folder structure next time a browser tries to access it. This is how the server-side cache works.</p>

<p>The client-side cache is managed by the browser, the PHP script will only tell the browser some basic information:</p>

<ol>
<li>The time when the HTML file was modified last</li>
<li>The time when the cache should expire</li>
</ol>

<p>Links to other MarkDown files can be written as usual, but they should point to a MarkDown file (not a cached HTML file, even if it&#39;s browser accessable).</p>

<h2>Disable caching</h2>

<h3>Server-side cache</h3>

<p>To disable the server-side cache, simply set the value of the constant <code>CACHE_ENABLED</code> to <code>false</code>. But will still use the filesystem, if the MarkDown converter wants to write a file.</p>

<p>To avoid using the filesystem here, the MarkDown converter needs to be able to output the HTML to the shell (modify the <code>MD_TO_HTML_CMD</code> value). As soon as you disabled the server-side cache and modified the MarkDown converter command to output HTML to the shell, you can set the value of <code>HTML_CACHE_DIR</code> to <code>null</code>.</p>

<h3>Browser cache</h3>

<p>To disable the browser cache support, simply set <code>MAX_CACHE_TIME</code> to <code>0</code>. This will avoid to interpret the received cache headers or send and cache headers to the client.</p>

<h2>Performance</h2>

<p>Of course converting MarkDown to HTML will take some time and use resources. But as soon as the converter is done, the generated HTML will be cached and re-used until you modify the MarkDown source file. All in all this results in a very good performance already.</p>

<p>For an even better performance, the <code>.htaccess</code> configuration could try to use the previously cached HTML file and only use the PHP script, if the HTML file doesn&#39;t exist. For this the <code>HTML_CACHE_DIR</code> should point to the MarkDown webroot. However, this option would skip the whole (server- AND client-side) cache control of the PHP script, and you would have to delete the HTML versions of updated MarkDown source files manually!</p>

<h2>Security</h2>

<p>If the called MarkDown file URI can&#39;t be resolved to an existing file, or the resolved full file path isn&#39;t under the folder that contains the <code>mdserver.php</code>, the PHP script will deny processing the request. The maximum URI path length is limited to 4096 characters.</p>

<p>The <code>.htaccess</code> will block any access to a <code>\/md(server|header|footer)(\.hook|\.conf)?\.(html|php)$</code> file. So <code>mdserver.php</code> can&#39;t be accessed directly, which is how it should be, because it should only be possible to run the PHP script from an internal relocation trough a <code>mod_rewrite</code> rule. Anyway, the <code>mdserver.php</code> contains an accessibility check, too.</p>

<h2>Customizing the output HTML</h2>

<h3>Adding a header/footer</h3>

<p>You can define the HTML to prepend/append to the generated HTML using the files <code>mdheader.html</code> and <code>mdfooter.html</code>. The header/footer won&#39;t be cached, so it may be modified at any time without having to clear the server side cache.</p>

<h3>Using a PHP hook</h3>

<p>Before the generated HTML is being written do the cache, a PHP script with the name <code>mdserver.hook.php</code> has the chance to modify the generated HTML and write the final HTML to use from and in the variable <code>$finalHtml</code>. If the value of <code>$finalHtml</code> is <code>null</code>, nothing will be sent to the client. If the value is an empty string, only the cache headers will be sent to the client.</p>

<!-- Add syntax highlighting -->
<link rel="stylesheet" media="(prefers-color-scheme: light)" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.3.1/styles/base16/default-light.min.css">
<link rel="stylesheet" media="(prefers-color-scheme: dark" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.3.1/styles/base16/default-dark.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.3.1/highlight.min.js"></script>
<script>hljs.highlightAll();</script>
